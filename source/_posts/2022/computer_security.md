---
title: 计算机网络
tags: [computer]
categories: [computer]
date: 2022-05-02 22:08:28
---
# 计算机网络

## SSH

**Secure Shell**（安全外壳协议，简称**SSH**）是一种加密的[网络传输协议](https://zh.wikipedia.org/wiki/网络传输协议)，可在不安全的网络中为网络服务提供安全的传输环境。SSH通过在网络中创建[安全隧道](https://zh.wikipedia.org/w/index.php?title=安全隧道&action=edit&redlink=1)来实现SSH客户端与服务器之间的连接)。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输[命令行界面](https://zh.wikipedia.org/wiki/命令行界面)和远程执行命令。SSH使用频率最高的场合是[类Unix系统](https://zh.wikipedia.org/wiki/类Unix系统)，但是[Windows](https://zh.wikipedia.org/wiki/Windows)操作系统也能有限度地使用SSH。2015年，微软宣布将在未来的操作系统中提供原生SSH协议支持，[Windows](https://zh.wikipedia.org/wiki/Windows) 10 1803版本已提供[OpenSSH](https://zh.wikipedia.org/wiki/OpenSSH)工具)。

SSH以[非对称加密](https://zh.wikipedia.org/wiki/非对称加密)实现[身份验证](https://zh.wikipedia.org/wiki/身份验证)[[2\]](https://zh.wikipedia.org/wiki/Secure_Shell#cite_note-rfc4252-2)。身份验证有多种途径，例如其中一种方法是使用自动生成的公钥-私钥对来简单地加密网络连接，随后使用密码认证进行登录；另一种方法是人工生成一对公钥和私钥，通过生成的密钥进行认证，这样就可以在不输入密码的情况下登录。任何人都可以自行生成密钥。公钥需要放在待访问的电脑之中，而对应的私钥需要由用户自行保管。认证过程基于生成出来的私钥，但整个认证过程中私钥本身不会传输到网络中。



SSH协议有两个主要版本，分别是SSH-1和SSH-2。无论是哪个版本，核实未知密钥来源都是重要的事情，因为SSH只验证提供用户是否拥有与公钥相匹配的私钥，只要接受公钥而且密钥匹配服务器就会授予许可。这样的话，一旦接受了恶意攻击者的公钥，那么系统也会把攻击者视为合法用户。



在[类Unix系统](https://zh.wikipedia.org/wiki/类Unix系统)中，已许可登录的公钥通常保存在用户 /home 目录的 ~/.ssh/authorized_keys 文件中[[10\]](https://zh.wikipedia.org/wiki/Secure_Shell#cite_note-10)，该文件只由SSH使用。当远程机器持有公钥，而本地持有对应私钥时，登录过程不再需要手动输入密码。另外为了额外的安全性，私钥本身也能用密码保护。

私钥会保存在固定位置，也可以通过命令行参数指定（例如ssh命令的“-i”选项）。[ssh-keygen](https://zh.wikipedia.org/wiki/Ssh-keygen)是生成密钥的工具之一。

SSH也支持基于密码的身份验证，此时密钥是自动生成的。若客户端和服务端从未进行过身份验证，SSH未记录服务器端所使用的密钥，那么攻击者可以模仿服务器端请求并获取密码，即[中间人攻击](https://zh.wikipedia.org/wiki/中间人攻击)。但是密码认证可以禁用，而且SSH客户端在发现新密钥或未知服务器时会向用户发出警告。

SSH协议框架中最主要的部分是三个协议：

1. **传输层协议**（The Transport Layer Protocol）：传输层协议提供[服务器](https://zh.wikipedia.org/wiki/服务器)认证，数据机密性，信息完整性等的支持。
2. **用户认证协议**（The User Authentication Protocol）：用户认证协议为服务器提供客户端的身份鉴别。
3. **连接协议**（The Connection Protocol）：连接协议将加密的信息隧道复用成若干个逻辑通道，提供给更高层的应用协议使用。

SSH的安全验证

在客户端来看，SSH提供两种级别的安全验证。

- 第一种级别（基于密码的安全验证），知道帐号和密码，就可以登录到远程主机，并且所有传输的数据都会被SSH传输层协议加密。但是，可能会有别的服务器在冒充真正的服务器，但只要客户端校验主机公钥，在服务器私钥不泄露的前提下就能避免被“中间人”攻击。
- 第二种级别（基于[密钥](https://zh.wikipedia.org/wiki/公开密钥加密)的安全验证），需要依靠密钥，也就是你必须为自己创建一对密钥，并把公钥放在需要访问的服务器上。客户端软件会向服务器发出请求，请求用你的私钥进行安全验证并发送使用私钥对会话ID等信息的签名。服务器收到请求之后，先在你在该服务器的用户根目录下寻找你的公钥，然后把它和你发送过来的公钥进行比较，并用公钥检验签名是否正确。如果两个密钥一致，且签名正确，服务器就认为用户登录成功。

在服务器端来看，SSH也提供安全验证。

- 服务器将自己的公钥分发给相关的客户端，并将密钥交换过程中的公开信息与协商密钥的哈希值的签名发送给客户端，客户端将获取的服务器公钥计算指纹并与其他安全信道获得的公钥指纹相比对并验证主机签名。
- 存在一个密钥认证中心，所有提供服务的主机都将自己的公钥提交给认证中心，公钥认证中心给服务端颁发证书，而任何作为客户端的主机则只要保存一份认证中心的公钥就可以了。在这种模式下，服务器会发送认证中心提供给主机的证书与主机对密钥交换过程中公开信息的签名。客户端只需要验证证书的有效性并验证签名。

## TLS/SSL

**传输层安全性协议**（英语：**T**ransport **L**ayer **S**ecurity，缩写：**TLS**）及其前身**安全套接层**（英语：**S**ecure **S**ockets **L**ayer，缩写：**SSL**）是一种[安全协议](https://zh.wikipedia.org/wiki/安全协议)，目的是为[互联网](https://zh.wikipedia.org/wiki/網際網路)通信提供安全及数据[完整性](https://zh.wikipedia.org/wiki/完整性)保障。[网景](https://zh.wikipedia.org/wiki/網景)公司（Netscape）在1994年推出首版[网页浏览器](https://zh.wikipedia.org/wiki/網頁瀏覽器)－[网景导航者](https://zh.wikipedia.org/wiki/網景領航員)时，**推出[HTTPS](https://zh.wikipedia.org/wiki/HTTPS)协议，以SSL进行加密，这是SSL的起源。**[IETF](https://zh.wikipedia.org/wiki/IETF)将SSL进行标准化，1999年公布TLS 1.0标准文件（[RFC 2246](https://tools.ietf.org/html/rfc2246)）。随后又公布TLS 1.1（[RFC 4346](https://tools.ietf.org/html/rfc4346)，2006年）、TLS 1.2（[RFC 5246](https://tools.ietf.org/html/rfc5246)，2008年）和TLS 1.3（[RFC 8446](https://tools.ietf.org/html/rfc8446)，2018年）。在[浏览器](https://zh.wikipedia.org/wiki/瀏覽器)、[电子邮件](https://zh.wikipedia.org/wiki/電子郵件)、[即时通信](https://zh.wikipedia.org/wiki/即時通訊)、[VoIP](https://zh.wikipedia.org/wiki/VoIP)、[网络传真](https://zh.wikipedia.org/wiki/網絡傳真)等应用程序中，广泛使用这个协议。许多网站，如[Google](https://zh.wikipedia.org/wiki/Google)、[Facebook](https://zh.wikipedia.org/wiki/Facebook)、[Wikipedia](https://zh.wikipedia.org/wiki/Wikipedia)等也以这个协议来创建安全连线，发送资料。目前已成为[互联网](https://zh.wikipedia.org/wiki/互联网)上保密通信的工业标准。

SSL包含记录层（Record Layer）和[传输层](https://zh.wikipedia.org/wiki/传输层)，记录层协议确定传输层数据的封装格式。传输层安全协议使用[X.509](https://zh.wikipedia.org/wiki/X.509)认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（[Session key](https://zh.wikipedia.org/wiki/Session_key)）。这个会谈密钥是用来将通信两方交换的资料做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。

## http

2xx：成功

3xx：重定向

4xx：客户端错误

5xx：服务端错误

![image-20220430124638634](https://raw.githubusercontent.com/crazyzsh/myImage/main/imageTest/202204301246734.png)
## http缓存
不同网站的反应头的大小写规则不一致，有的以大写开头，中间以-进行连接，有的以小写开头，中间以-进行连接

* cache-control：

  * cache-control:max-age=31536000，这里单位为秒，即一年（b站为例）

  * cache-control:no-cache，例如html资源，并不意味着不进行缓存，而是每次使用缓存时都和服务器进行确认，同时代理服务器也不能进行缓存，一般网页框架不会经常变动就可以这样设置。
  * cache-control:no-store，不进行缓存

  * Cache-Control:private：表示所有代理服务器都不能进行资源缓存，只有浏览器可以进行缓存

  * Cache-Control:public：表示浏览器和代理服务器都可以进行缓存

* etag：标识资源（例如图片等资源会有此），一般来说，每次资源更新后，新的etag值也会被服务器更新
* expires：缓存过期时间，在过期时间之前，不会向服务器要求更新资源
* last-modified：如果服务器在上次被请求后进行了资源更新，那么下一次请求时所请求到的资源就会不一样，即上次的缓存（这里的上次指的是某一次有效缓存）就不可以使用了。所以此字段可以判断资源最新修改时间是否与上次缓存时最新修改时间一致，如果一致，表示资源没有别修改，如果不一致，就得让服务器重新返回新的资源了。

## 浏览器中输入URL之后发生的事

输入url之后就会通过DNS进行解析，解析到某个固定的ip地址

![image-20220430140648255](https://raw.githubusercontent.com/crazyzsh/myImage/main/imageTest/202204301406294.png)![image-20220430140658971](https://raw.githubusercontent.com/crazyzsh/myImage/main/imageTest/202204301406999.png)

## http/https

http协议的请求报文和响应报文都是明文的，这就使得传输不安全，于是就有了https，https在http的基础上用TLS/SSL进行加密，这样通信就不容易收到拦截和攻击。SSL是TLS的前身

## TCP三次握手和四次挥手

例如edge浏览器和谷歌浏览器分别同时登入B站，此时本机的ip是一致的，不同的是端口号，即Edge浏览器和Chrome浏览器被分配的端口不一样，所以才能同时进行登入，互不干扰。

ip地址+端口号被称为套接字（socket）

TCP报文中有SYN，ACK（acknowledgment：确认），FIN等标识，

三次握手

TCP/IP 协议是传输层的一个面向连接的安全可靠的一个传输协议，三次握手的机制是为了保证能建立一个安全可靠的连接，那么第一次握手是由客户端发起，客户端会向服务端发送一个报文，在报文里面：SYN标志位置为1，表示发起新的连接。当服务端收到这个报文之后就知道客户端要和我建立一个新的连接，于是服务端就向客户端发送一个确认消息包，在这个消息包里面：ack标志位置为1，表示确认客户端发起的第一次连接请求。以上两次握手之后，对于客户端而言：已经明确了我既能给服务端成功发消息，也能成功收到服务端的响应。但是对于服务端而言：两次握手是不够的，因为到目前为止，服务端只知道一件事，客户端发给我的消息我能收到，但是我响应给客户端的消息，客户端能不能收到我是不知道的。所以，还需要进行第三次握手，第三次握手就是当客户端收到服务端发送的确认响应报文之后，还要继续去给服务端进行回应，也是一个ack标志位置1的确认消息。通过以上三次连接，不管是客户端还是服务端，都知道我既能给对方发送消息，也能收到对方的响应。那么，这个连接就被安全的建了。

![image-20220430160348523](https://raw.githubusercontent.com/crazyzsh/myImage/main/imageTest/202204301603585.png)

四次挥手

四次挥手：由客户端首先发起的，第一次挥手客户端会发送一个报文，在报文里面FIN标志位置1，当服务端收到这个报文就知道了客户端想要和我断开连接，但是此时服务端不一定能做好准备，因为当客户端发起断开连接的请求后，对于服务端而言还极有可能有未发送完的消息，还需继续发送，所以此时对于服务端而言只能进行一个消息确认（第二次挥手），即告诉客户端我知道你要和我断开连接，但是我这边还可能没有做好准备，你需要等我一下，等会儿我会告诉你（第三次挥手），于是，发完这个消息确认包过后，可能稍过片刻，服务端会继续发送一个断开连接的报文（第三次挥手），FIN位置1的报文，表示服务端已经做好断开连接的准备，当这个报文发给客户端的时候，客户端同样要给服务端发送一个消息确认的报文（第四次挥手），经过这四次的相互沟通和连接，我就知道了不管是客户端还是服务端都已经做好了断开连接的准备，于是连接断开了，这是我对......

![image-20220430160305171](https://raw.githubusercontent.com/crazyzsh/myImage/main/imageTest/202204301603241.png)
## 公钥和私钥
> 对称秘钥系统

理想情况：加密算法只对接收者公开，他人无法得知加密算法，相当于发送者和接收者各持一把钥匙，此时数据是绝对安全的。但是现实是几乎所有的加密算法都是公开的。

> 公开秘钥系统（效率比较低）

实际情况1：公钥即公开的，公钥能解密私钥加密的数据，私钥也能解密公钥加密的数据。**发送者**使用**接收者**的<u>公钥</u>进行加密，**接收者**使用自己的**秘钥**进行解密，但是中间过程容易被劫持篡改，接收者不能确定中间过程是否被劫持篡改，此时就需要**数字签名**来确定发送者传输过来的数据是否被篡改，以确保数据绝对的安全。

> 数字签名(与上述的公开秘钥系统配合使用)

数字签名的原理是：**发送者**使用自己的私钥对报文进行加密，形成数字签名，然后将签名连同文件一同发送给接收者，**接收者**使用发送者的公钥对签名进行解密，与收到的明文（公开秘钥系统中解密出来的）进行**对比**，如果相同，则未被篡改，一定能验证报文来自发送方，因为既然能用**发送者**的**公钥**解密出原始数据，那就证明这段数据一定是用发送方的私钥进行加密的。数字签名不仅能用来识别数据发送方，同时还保证了数据的完整性，因为如果报文被篡改，接收方收到数据后用签名计算出的报文一定与接收数据不相同

> 密码散列函数（一对一，即输入是什么，输出唯一，如果输入被修改则输出也被修改），被称为“数据指纹”

仅仅是为了签名而对完整的报文进行私钥加密计算，代价比较昂贵，可以用到密码散列函数，先得到原始报文的摘要，再对摘要进行签名